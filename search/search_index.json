{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"index","text":""},{"location":"getting-start/","title":"Getting Started with Agents Service","text":"<p>Welcome to Agents Service \u2013 an agentic microservice built using LangGraph. This guide will help you set up the project on your local machine, run the service, and get started with development.</p>"},{"location":"getting-start/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Python 3.12 or higher</li> <li>uv \u2013 a modern dependency and environment manager   (Installation instructions: uv GitHub Repository)</li> <li>Docker</li> </ul>"},{"location":"getting-start/#1-clone-the-repository","title":"1. Clone the Repository","text":"<p>First, clone the repository from GitHub:</p> <pre><code>git clone https://github.com/FabioCaffarello/agents-service.git\ncd agents-service\n</code></pre>"},{"location":"getting-start/#2-set-up-the-virtual-environment","title":"2. Set Up the Virtual Environment","text":"<p>Your project uses uv to manage the virtual environment and dependencies. The Makefile includes a <code>setup</code> target that handles environment creation, dependency installation, and pre-commit hook setup.</p> <p>Run the following command to set up the project:</p> <pre><code>make setup\n</code></pre> <p>This command performs the following steps: - Creates a virtual environment in the <code>.venv</code> directory. - Installs all dependencies including development and documentation extras. - Sets executable permissions on the branch-check script. - Installs the pre-commit hooks for both commit and push stages.</p>"},{"location":"getting-start/#3-running-the-service","title":"3. Running the Service","text":"<p>To start the development server (with auto-reload), run:</p> <p>&lt;!-- ```bash uv run python -m uvicorn src.main:app --reload <pre><code>Then, open your browser and visit [http://127.0.0.1:8000](http://127.0.0.1:8000) to view the service.\n\n--- --&gt;\n\n## 4. Running Tests\n\nTo run the test suite, use the Makefile target for checking tests:\n\n```bash\nmake check\n</code></pre></p> <p>This command executes <code>pytest</code> within the uv-managed environment.</p>"},{"location":"getting-start/#5-linting-and-code-quality","title":"5. Linting and Code Quality","text":"<p>To format and lint your code, use the following targets:</p> <ul> <li>Format Code (using Ruff):</li> </ul> <pre><code>make format\n</code></pre> <ul> <li>Lint Code (using Ruff):</li> </ul> <pre><code>make lint\n</code></pre> <ul> <li>Run Pre-commit Hooks:</li> </ul> <pre><code>make precommit\n</code></pre>"},{"location":"getting-start/#6-documentation","title":"6. Documentation","text":""},{"location":"getting-start/#serve-documentation-locally","title":"Serve Documentation Locally","text":"<p>Your project documentation is managed with MkDocs. To serve the docs locally with live-reloading, run:</p> <pre><code>make server-docs\n</code></pre> <p>Then, visit http://127.0.0.1:8000 in your browser.</p>"},{"location":"getting-start/#deploy-documentation","title":"Deploy Documentation","text":"<p>To deploy the documentation to GitHub Pages, run:</p> <pre><code>make deploy-docs\n</code></pre> <p>This command will build the documentation and push it to the appropriate branch for GitHub Pages.</p>"},{"location":"getting-start/#7-additional-commands","title":"7. Additional Commands","text":"<p>For other tasks, refer to the Makefile by running:</p> <pre><code>make help\n</code></pre> <p>This will list all available commands and their descriptions.</p>"},{"location":"getting-start/#8-troubleshooting","title":"8. Troubleshooting","text":"<ul> <li> <p>Virtual Environment Issues:   If you encounter any issues with the virtual environment, try running <code>make clean</code> to clear caches and temporary files, then run <code>make setup</code> again.</p> </li> <li> <p>Pre-commit Hooks:   If pre-commit hooks aren\u2019t running as expected, ensure they\u2019re installed by running:</p> </li> </ul> <pre><code>pre-commit install\n</code></pre> <ul> <li>Dependency Updates:   When you update your dependencies in <code>pyproject.toml</code>, remember to run:</li> </ul> <pre><code>uv lock\n</code></pre> <p>to update the lock file.</p>"},{"location":"summary/","title":"Summary","text":"<ul> <li>Home</li> <li>Getting Start</li> <li>Service</li> <li>Packages</li> </ul>"},{"location":"reference/","title":"Agents Service","text":""},{"location":"reference/#overview","title":"Overview","text":"<p>The Agents Service is a backend system designed to orchestrate and manage AI-driven agents following agentic design patterns. The service integrates various agents, strategies, and execution frameworks, exposing a secure and extensible API using FastAPI.</p>"},{"location":"reference/#key-features","title":"Key Features","text":"<ul> <li>Agent Management: Create, manage, and query agents dynamically.</li> <li>Security: Authentication and authorization with JWT.</li> <li>Multiple Interfaces: Support for REST, WebSockets, and future extension to gRPC or GraphQL.</li> <li>Modular Architecture: Based on Clean Architecture and DDD.</li> <li>Scalability: Designed for future microservice adoption.</li> </ul>"},{"location":"reference/#architecture-overview","title":"Architecture Overview","text":"<p>The Agents Service follows the Clean Architecture principles, ensuring separation of concerns and maintainability. It is structured into the following layers:</p> <ol> <li>Core Domain</li> <li>Agents and Strategy Modules</li> <li>Registry for managing agent lifecycles</li> <li> <p>Protocols for dependency inversion</p> </li> <li> <p>Application Layer</p> </li> <li>Use Cases for agent operations</li> <li> <p>DTOs and Value Objects for consistent data handling</p> </li> <li> <p>Infrastructure Layer</p> </li> <li>Security module for authentication and authorization</li> <li> <p>Logging and configuration management</p> </li> <li> <p>Interface Layer (Presenters)</p> </li> <li>FastAPI-based REST controllers</li> <li>Authentication endpoints</li> </ol>"},{"location":"reference/#c4-model-diagrams","title":"C4 Model Diagrams","text":""},{"location":"reference/#context-diagram","title":"Context Diagram","text":""},{"location":"reference/#container-diagram","title":"Container Diagram","text":""},{"location":"reference/#component-diagram","title":"Component Diagram","text":""},{"location":"reference/#next-steps","title":"Next Steps","text":"<ul> <li>Refine Diagrams: Add deployment and sequence diagrams.</li> <li>Detail Use Cases: Write specifications for each application use case.</li> <li>Define API Contracts: Standardize request and response models.</li> <li>Write Usage Guides: Provide documentation for developers.</li> </ul> <p>This structured documentation will ensure a well-guided development process with a clear architectural vision! \ud83d\ude80</p>"},{"location":"reference/docs/","title":"index","text":""},{"location":"reference/docs/getting-start/","title":"Getting Started with Agents Service","text":"<p>Welcome to Agents Service \u2013 an agentic microservice built using LangGraph. This guide will help you set up the project on your local machine, run the service, and get started with development.</p>"},{"location":"reference/docs/getting-start/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Python 3.12 or higher</li> <li>uv \u2013 a modern dependency and environment manager   (Installation instructions: uv GitHub Repository)</li> <li>Docker</li> </ul>"},{"location":"reference/docs/getting-start/#1-clone-the-repository","title":"1. Clone the Repository","text":"<p>First, clone the repository from GitHub:</p> <pre><code>git clone https://github.com/FabioCaffarello/agents-service.git\ncd agents-service\n</code></pre>"},{"location":"reference/docs/getting-start/#2-set-up-the-virtual-environment","title":"2. Set Up the Virtual Environment","text":"<p>Your project uses uv to manage the virtual environment and dependencies. The Makefile includes a <code>setup</code> target that handles environment creation, dependency installation, and pre-commit hook setup.</p> <p>Run the following command to set up the project:</p> <pre><code>make setup\n</code></pre> <p>This command performs the following steps: - Creates a virtual environment in the <code>.venv</code> directory. - Installs all dependencies including development and documentation extras. - Sets executable permissions on the branch-check script. - Installs the pre-commit hooks for both commit and push stages.</p>"},{"location":"reference/docs/getting-start/#3-running-the-service","title":"3. Running the Service","text":"<p>To start the development server (with auto-reload), run:</p> <p>&lt;!-- ```bash uv run python -m uvicorn src.main:app --reload <pre><code>Then, open your browser and visit [http://127.0.0.1:8000](http://127.0.0.1:8000) to view the service.\n\n--- --&gt;\n\n## 4. Running Tests\n\nTo run the test suite, use the Makefile target for checking tests:\n\n```bash\nmake check\n</code></pre></p> <p>This command executes <code>pytest</code> within the uv-managed environment.</p>"},{"location":"reference/docs/getting-start/#5-linting-and-code-quality","title":"5. Linting and Code Quality","text":"<p>To format and lint your code, use the following targets:</p> <ul> <li>Format Code (using Ruff):</li> </ul> <pre><code>make format\n</code></pre> <ul> <li>Lint Code (using Ruff):</li> </ul> <pre><code>make lint\n</code></pre> <ul> <li>Run Pre-commit Hooks:</li> </ul> <pre><code>make precommit\n</code></pre>"},{"location":"reference/docs/getting-start/#6-documentation","title":"6. Documentation","text":""},{"location":"reference/docs/getting-start/#serve-documentation-locally","title":"Serve Documentation Locally","text":"<p>Your project documentation is managed with MkDocs. To serve the docs locally with live-reloading, run:</p> <pre><code>make server-docs\n</code></pre> <p>Then, visit http://127.0.0.1:8000 in your browser.</p>"},{"location":"reference/docs/getting-start/#deploy-documentation","title":"Deploy Documentation","text":"<p>To deploy the documentation to GitHub Pages, run:</p> <pre><code>make deploy-docs\n</code></pre> <p>This command will build the documentation and push it to the appropriate branch for GitHub Pages.</p>"},{"location":"reference/docs/getting-start/#7-additional-commands","title":"7. Additional Commands","text":"<p>For other tasks, refer to the Makefile by running:</p> <pre><code>make help\n</code></pre> <p>This will list all available commands and their descriptions.</p>"},{"location":"reference/docs/getting-start/#8-troubleshooting","title":"8. Troubleshooting","text":"<ul> <li> <p>Virtual Environment Issues:   If you encounter any issues with the virtual environment, try running <code>make clean</code> to clear caches and temporary files, then run <code>make setup</code> again.</p> </li> <li> <p>Pre-commit Hooks:   If pre-commit hooks aren\u2019t running as expected, ensure they\u2019re installed by running:</p> </li> </ul> <pre><code>pre-commit install\n</code></pre> <ul> <li>Dependency Updates:   When you update your dependencies in <code>pyproject.toml</code>, remember to run:</li> </ul> <pre><code>uv lock\n</code></pre> <p>to update the lock file.</p>"},{"location":"reference/docs/summary/","title":"Summary","text":"<ul> <li>Home</li> <li>Getting Start</li> <li>Service</li> <li>Packages</li> </ul>"},{"location":"reference/packages/agents-graph/agents/code_reference/src/agents/joke_agents/","title":"Joke agents","text":""},{"location":"reference/packages/agents-graph/agents/code_reference/src/agents/scraping_agents/","title":"Scraping agents","text":""},{"location":"reference/packages/agents-graph/agents/code_reference/src/agents/scraping_agents/#packages.agents-graph.agents.src.agents.scraping_agents.IPBlockDetectorAgent","title":"<code>IPBlockDetectorAgent</code>","text":"<p>               Bases: <code>BaseAgent</code></p> <p>Detects if the request is ip_blocked due to IP or proxy issues using both deterministic checks and low-cost LLM-augmented analysis via bound tools.</p> Source code in <code>packages/agents-graph/agents/src/agents/scraping_agents.py</code> <pre><code>class IPBlockDetectorAgent(BaseAgent):\n    \"\"\"\n    Detects if the request is ip_blocked due to IP or proxy issues using both\n    deterministic checks and low-cost LLM-augmented analysis via bound tools.\n    \"\"\"\n\n    def run(self, status: int, headers: dict) -&gt; dict:\n        # --- Deterministic checks ---\n        if status in (403, 429):\n            return {\n                \"ip_blocked\": True,\n                \"ip_reason\": f\"HTTP status {status} indicates possible IP block.\",\n            }\n\n        proxy_block_headers = [\"X-Blocked-Reason\", \"X-IP-Blocked\"]\n        for header in proxy_block_headers:\n            if header in headers:\n                return {\n                    \"ip_blocked\": True,\n                    \"ip_reason\": f\"Header {header} indicates an IP block.\",\n                }\n\n        # --- Low-cost LLM analysis via bound tools ---\n        def analyze_status(s: int) -&gt; str:\n            if s in (403, 429):\n                return f\"Status code {s} strongly suggests an IP block.\"\n            return f\"Status code {s} appears normal.\"\n\n        def analyze_headers(h: dict) -&gt; str:\n            for key in proxy_block_headers:\n                if key in h:\n                    return f\"Header {key} indicates an IP block.\"\n            return \"No blocking indicators found in headers.\"\n\n        llm_with_tools = self.llm.bind_tools([analyze_status, analyze_headers])\n        prompt = (\n            \"Based on the following metadata, determine if there is an IP block and explain your reasoning.\\n\"\n            f\"Status: {status}\\n\"\n            f\"Headers: {headers}\\n\"\n            \"Answer in the format: 'blocked: &lt;reason&gt;' or 'not blocked: &lt;explanation&gt;'.\"\n        )\n        response = llm_with_tools.invoke(prompt)\n        # Ensure a fallback is provided if the response is empty.\n        if response and response.content:\n            if \"blocked\" in response.content.lower():\n                return {\"ip_blocked\": True, \"ip_reason\": response.content.strip()}\n            else:\n                return {\"ip_blocked\": False, \"ip_reason\": response.content.strip()}\n        else:\n            return {\n                \"ip_blocked\": False,\n                \"ip_reason\": f\"Status code {status} appears normal.\",\n            }\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/agent/","title":"Agent","text":""},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/agent/#packages.agents-graph.agents-core.src.agents_core.agent.Agent","title":"<code>Agent</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all agents.</p> Source code in <code>packages/agents-graph/agents-core/src/agents_core/agent.py</code> <pre><code>class Agent(ABC):\n    \"\"\"Abstract base class for all agents.\"\"\"\n\n    @abstractmethod\n    def run(self, **kwargs) -&gt; dict:\n        \"\"\"Execute the agent's logic.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/agent/#packages.agents-graph.agents-core.src.agents_core.agent.Agent.run","title":"<code>run(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Execute the agent's logic.</p> Source code in <code>packages/agents-graph/agents-core/src/agents_core/agent.py</code> <pre><code>@abstractmethod\ndef run(self, **kwargs) -&gt; dict:\n    \"\"\"Execute the agent's logic.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/base_agent/","title":"Base agent","text":""},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/base_agent/#packages.agents-graph.agents-core.src.agents_core.base_agent.BaseMetadataAgent","title":"<code>BaseMetadataAgent</code>","text":"<p>               Bases: <code>Agent</code></p> <p>A simple agent implementation that accepts a name.</p> Source code in <code>packages/agents-graph/agents-core/src/agents_core/base_agent.py</code> <pre><code>class BaseMetadataAgent(Agent):\n    \"\"\"A simple agent implementation that accepts a name.\"\"\"\n\n    def __init__(self, name: str):\n        self.id = AgentID.generate()\n        self.name = name\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/dynamic_agent_factory/","title":"Dynamic agent factory","text":""},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/dynamic_agent_factory/#packages.agents-graph.agents-core.src.agents_core.dynamic_agent_factory.DynamicAgentFactory","title":"<code>DynamicAgentFactory</code>","text":"Source code in <code>packages/agents-graph/agents-core/src/agents_core/dynamic_agent_factory.py</code> <pre><code>class DynamicAgentFactory:\n    def __init__(self, llm):\n        self.llm = llm\n        self.agent_registrations = self._get_agent_registrations()\n\n    def _get_agent_registrations(self) -&gt; List[dict]:\n        return [\n            {\n                \"alias\": \"joke_generator\",\n                \"class_path\": \"agents.joke_agents.JokeGeneratorAgent\",\n                \"config\": {\"prompt_template\": \"Write a short joke about {topic}\"},\n            },\n            {\n                \"alias\": \"joke_improver\",\n                \"class_path\": \"agents.joke_agents.JokeImproverAgent\",\n                \"config\": {\n                    \"prompt_template\": \"Make this joke funnier by adding wordplay: {joke}\"\n                },\n            },\n            {\n                \"alias\": \"joke_polisher\",\n                \"class_path\": \"agents.joke_agents.JokePolisherAgent\",\n                \"config\": {\n                    \"prompt_template\": \"Add a surprising twist to this joke: {improved_joke}\"\n                },\n            },\n            {\n                \"alias\": \"ip_detector\",\n                \"class_path\": \"agents.scraping_agents.IPBlockDetectorAgent\",\n            },\n        ]\n\n    def create_agent(self, alias: str) -&gt; BaseAgent:\n        \"\"\"\n        Create an agent instance by its alias.\n        \"\"\"\n        agent_info = next(\n            (item for item in self.agent_registrations if item[\"alias\"] == alias), None\n        )\n        if not agent_info:\n            raise ValueError(f\"Agent with alias '{alias}' not found.\")\n\n        class_path = agent_info[\"class_path\"]\n        module_name, class_name = class_path.rsplit(\".\", 1)\n        module = importlib.import_module(module_name)\n        agent_class = getattr(module, class_name)\n\n        return agent_class(alias, self.llm, agent_info.get(\"config\", {}))\n\n    def create_agents(self, aliases: list) -&gt; dict:\n        \"\"\"\n        Create multiple agents and return a dict mapping alias -&gt; agent instance.\n        \"\"\"\n        return {alias: self.create_agent(alias) for alias in aliases}\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/dynamic_agent_factory/#packages.agents-graph.agents-core.src.agents_core.dynamic_agent_factory.DynamicAgentFactory.create_agent","title":"<code>create_agent(alias)</code>","text":"<p>Create an agent instance by its alias.</p> Source code in <code>packages/agents-graph/agents-core/src/agents_core/dynamic_agent_factory.py</code> <pre><code>def create_agent(self, alias: str) -&gt; BaseAgent:\n    \"\"\"\n    Create an agent instance by its alias.\n    \"\"\"\n    agent_info = next(\n        (item for item in self.agent_registrations if item[\"alias\"] == alias), None\n    )\n    if not agent_info:\n        raise ValueError(f\"Agent with alias '{alias}' not found.\")\n\n    class_path = agent_info[\"class_path\"]\n    module_name, class_name = class_path.rsplit(\".\", 1)\n    module = importlib.import_module(module_name)\n    agent_class = getattr(module, class_name)\n\n    return agent_class(alias, self.llm, agent_info.get(\"config\", {}))\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/dynamic_agent_factory/#packages.agents-graph.agents-core.src.agents_core.dynamic_agent_factory.DynamicAgentFactory.create_agents","title":"<code>create_agents(aliases)</code>","text":"<p>Create multiple agents and return a dict mapping alias -&gt; agent instance.</p> Source code in <code>packages/agents-graph/agents-core/src/agents_core/dynamic_agent_factory.py</code> <pre><code>def create_agents(self, aliases: list) -&gt; dict:\n    \"\"\"\n    Create multiple agents and return a dict mapping alias -&gt; agent instance.\n    \"\"\"\n    return {alias: self.create_agent(alias) for alias in aliases}\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/model_config/","title":"Model config","text":""},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/registry/","title":"Registry","text":""},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/registry/#packages.agents-graph.agents-core.src.agents_core.registry.AgentRegistry","title":"<code>AgentRegistry</code>","text":"<p>Concrete implementation of AgentRegistryProtocol.</p> Source code in <code>packages/agents-graph/agents-core/src/agents_core/registry.py</code> <pre><code>class AgentRegistry:\n    \"\"\"Concrete implementation of AgentRegistryProtocol.\"\"\"\n\n    _registry: Dict[str, Type[Agent]] = {\"base\": BaseMetadataAgent}\n\n    def register(self, name: str, agent_cls: Type[Agent]) -&gt; None:\n        \"\"\"Register a new agent class.\"\"\"\n        self._registry[name] = agent_cls\n\n    def get_agent(self, name: str) -&gt; Type[Agent]:\n        \"\"\"Retrieve an agent by name.\"\"\"\n        if name not in self._registry:\n            raise ValueError(f\"Agent '{name}' not found in registry.\")\n        return self._registry[name]\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/registry/#packages.agents-graph.agents-core.src.agents_core.registry.AgentRegistry.register","title":"<code>register(name, agent_cls)</code>","text":"<p>Register a new agent class.</p> Source code in <code>packages/agents-graph/agents-core/src/agents_core/registry.py</code> <pre><code>def register(self, name: str, agent_cls: Type[Agent]) -&gt; None:\n    \"\"\"Register a new agent class.\"\"\"\n    self._registry[name] = agent_cls\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/registry/#packages.agents-graph.agents-core.src.agents_core.registry.AgentRegistry.get_agent","title":"<code>get_agent(name)</code>","text":"<p>Retrieve an agent by name.</p> Source code in <code>packages/agents-graph/agents-core/src/agents_core/registry.py</code> <pre><code>def get_agent(self, name: str) -&gt; Type[Agent]:\n    \"\"\"Retrieve an agent by name.\"\"\"\n    if name not in self._registry:\n        raise ValueError(f\"Agent '{name}' not found in registry.\")\n    return self._registry[name]\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/registry_protocol/","title":"Registry protocol","text":""},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/registry_protocol/#packages.agents-graph.agents-core.src.agents_core.registry_protocol.AgentRegistryProtocol","title":"<code>AgentRegistryProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines a protocol for agent registries.</p> Source code in <code>packages/agents-graph/agents-core/src/agents_core/registry_protocol.py</code> <pre><code>class AgentRegistryProtocol(Protocol):\n    \"\"\"Defines a protocol for agent registries.\"\"\"\n\n    def register(self, name: str, agent_cls: Type[Agent]) -&gt; None:\n        \"\"\"Registers an agent class.\"\"\"\n        pass\n\n    def get_agent(self, name: str) -&gt; Type[Agent]:\n        \"\"\"Retrieves an agent class by name.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/registry_protocol/#packages.agents-graph.agents-core.src.agents_core.registry_protocol.AgentRegistryProtocol.register","title":"<code>register(name, agent_cls)</code>","text":"<p>Registers an agent class.</p> Source code in <code>packages/agents-graph/agents-core/src/agents_core/registry_protocol.py</code> <pre><code>def register(self, name: str, agent_cls: Type[Agent]) -&gt; None:\n    \"\"\"Registers an agent class.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-core/code_reference/src/agents_core/registry_protocol/#packages.agents-graph.agents-core.src.agents_core.registry_protocol.AgentRegistryProtocol.get_agent","title":"<code>get_agent(name)</code>","text":"<p>Retrieves an agent class by name.</p> Source code in <code>packages/agents-graph/agents-core/src/agents_core/registry_protocol.py</code> <pre><code>def get_agent(self, name: str) -&gt; Type[Agent]:\n    \"\"\"Retrieves an agent class by name.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-orchestrators/code_reference/src/agents_orchestrators/base_orchestrator/","title":"Base orchestrator","text":""},{"location":"reference/packages/agents-graph/agents-orchestrators/code_reference/src/agents_orchestrators/scrapping_error_orchestrator/","title":"Scrapping error orchestrator","text":""},{"location":"reference/packages/agents-graph/agents-orchestrators/code_reference/src/agents_orchestrators/scrapping_error_orchestrator/#packages.agents-graph.agents-orchestrators.src.agents_orchestrators.scrapping_error_orchestrator.ScrapingErrorOrchestrator","title":"<code>ScrapingErrorOrchestrator</code>","text":"<p>               Bases: <code>BaseOrchestrator</code></p> Source code in <code>packages/agents-graph/agents-orchestrators/src/agents_orchestrators/scrapping_error_orchestrator.py</code> <pre><code>class ScrapingErrorOrchestrator(BaseOrchestrator):\n    def __init__(self, model_config: ModelConfig):\n        super().__init__(model_config)\n\n    async def process_payload(self, payload: dict) -&gt; dict:\n        \"\"\"\n        A stub orchestrator for scraping usage.\n        \"\"\"\n        payload_dto = ScrapingErrorPayloadDTO.from_dict(payload)\n\n        workflow = ScrapingErrorWorkflow(self.llm, payload_dto)\n        result = await workflow.run()\n        log.info(f\"Processed payload: {result}\")\n\n        await asyncio.sleep(0.5)  # Simulate processing delay.\n        return {\n            \"status\": \"scheduled\",\n            \"usage\": \"scraping\",\n        }\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-orchestrators/code_reference/src/agents_orchestrators/scrapping_error_orchestrator/#packages.agents-graph.agents-orchestrators.src.agents_orchestrators.scrapping_error_orchestrator.ScrapingErrorOrchestrator.process_payload","title":"<code>process_payload(payload)</code>  <code>async</code>","text":"<p>A stub orchestrator for scraping usage.</p> Source code in <code>packages/agents-graph/agents-orchestrators/src/agents_orchestrators/scrapping_error_orchestrator.py</code> <pre><code>async def process_payload(self, payload: dict) -&gt; dict:\n    \"\"\"\n    A stub orchestrator for scraping usage.\n    \"\"\"\n    payload_dto = ScrapingErrorPayloadDTO.from_dict(payload)\n\n    workflow = ScrapingErrorWorkflow(self.llm, payload_dto)\n    result = await workflow.run()\n    log.info(f\"Processed payload: {result}\")\n\n    await asyncio.sleep(0.5)  # Simulate processing delay.\n    return {\n        \"status\": \"scheduled\",\n        \"usage\": \"scraping\",\n    }\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-orchestrators/code_reference/src/agents_orchestrators/scrapping_orchestrator/","title":"Scrapping orchestrator","text":""},{"location":"reference/packages/agents-graph/agents-orchestrators/code_reference/src/agents_orchestrators/scrapping_orchestrator/#packages.agents-graph.agents-orchestrators.src.agents_orchestrators.scrapping_orchestrator.ScrapingOrchestrator","title":"<code>ScrapingOrchestrator</code>","text":"<p>               Bases: <code>BaseOrchestrator</code></p> Source code in <code>packages/agents-graph/agents-orchestrators/src/agents_orchestrators/scrapping_orchestrator.py</code> <pre><code>class ScrapingOrchestrator(BaseOrchestrator):\n    def __init__(self, model_config: ModelConfig):\n        super().__init__(model_config)\n\n    async def process_payload(self, payload: dict) -&gt; dict:\n        \"\"\"\n        A stub orchestrator for scraping usage.\n        \"\"\"\n        payload_dto = ScrapingPayloadDTO.from_dict(payload)\n        workflow = ScrapingWorkflow(self.llm, payload_dto)\n        result = await workflow.run()\n        log.info(f\"Processed payload: {result}\")\n\n        await asyncio.sleep(0.5)  # Simulate processing delay.\n        return {\n            \"status\": \"scheduled\",\n            \"usage\": \"scraping\",\n        }\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-orchestrators/code_reference/src/agents_orchestrators/scrapping_orchestrator/#packages.agents-graph.agents-orchestrators.src.agents_orchestrators.scrapping_orchestrator.ScrapingOrchestrator.process_payload","title":"<code>process_payload(payload)</code>  <code>async</code>","text":"<p>A stub orchestrator for scraping usage.</p> Source code in <code>packages/agents-graph/agents-orchestrators/src/agents_orchestrators/scrapping_orchestrator.py</code> <pre><code>async def process_payload(self, payload: dict) -&gt; dict:\n    \"\"\"\n    A stub orchestrator for scraping usage.\n    \"\"\"\n    payload_dto = ScrapingPayloadDTO.from_dict(payload)\n    workflow = ScrapingWorkflow(self.llm, payload_dto)\n    result = await workflow.run()\n    log.info(f\"Processed payload: {result}\")\n\n    await asyncio.sleep(0.5)  # Simulate processing delay.\n    return {\n        \"status\": \"scheduled\",\n        \"usage\": \"scraping\",\n    }\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-workflows/code_reference/src/agents_workflows/scraping_error_workflow/","title":"Scraping error workflow","text":""},{"location":"reference/packages/agents-graph/agents-workflows/code_reference/src/agents_workflows/scraping_error_workflow/#packages.agents-graph.agents-workflows.src.agents_workflows.scraping_error_workflow.ScrapingErrorWorkflow","title":"<code>ScrapingErrorWorkflow</code>","text":"Source code in <code>packages/agents-graph/agents-workflows/src/agents_workflows/scraping_error_workflow.py</code> <pre><code>class ScrapingErrorWorkflow:\n    def __init__(self, llm, payload: ScrapingPayloadDTO):\n        self.llm = llm\n        self.payload = payload\n        self.agent_factory = DynamicAgentFactory(llm)\n\n    async def run(self):\n        \"\"\"\n        Runs the scraping workflow.\n        \"\"\"\n        await asyncio.sleep(0.5)\n\n        return {\n            \"usage\": \"scraping\",\n            \"bot_name\": self.payload.bot_name,\n            \"processed_data\": self.payload,\n        }\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-workflows/code_reference/src/agents_workflows/scraping_error_workflow/#packages.agents-graph.agents-workflows.src.agents_workflows.scraping_error_workflow.ScrapingErrorWorkflow.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Runs the scraping workflow.</p> Source code in <code>packages/agents-graph/agents-workflows/src/agents_workflows/scraping_error_workflow.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Runs the scraping workflow.\n    \"\"\"\n    await asyncio.sleep(0.5)\n\n    return {\n        \"usage\": \"scraping\",\n        \"bot_name\": self.payload.bot_name,\n        \"processed_data\": self.payload,\n    }\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-workflows/code_reference/src/agents_workflows/scraping_workflow/","title":"Scraping workflow","text":""},{"location":"reference/packages/agents-graph/agents-workflows/code_reference/src/agents_workflows/scraping_workflow/#packages.agents-graph.agents-workflows.src.agents_workflows.scraping_workflow.ScrapingWorkflow","title":"<code>ScrapingWorkflow</code>","text":"Source code in <code>packages/agents-graph/agents-workflows/src/agents_workflows/scraping_workflow.py</code> <pre><code>class ScrapingWorkflow:\n    def __init__(self, llm, payload: ScrapingPayloadDTO):\n        self.llm = llm\n        self.payload = payload\n        self.agent_factory = DynamicAgentFactory(llm)\n\n    async def run(self):\n        \"\"\"\n        Runs the scraping workflow.\n        \"\"\"\n        await asyncio.sleep(0.5)\n        workflow = StateGraph(State)\n\n        # Dynamically create agents.\n        ip_detector = self.agent_factory.create_agent(\"ip_detector\")\n        gen_agent = self.agent_factory.create_agent(\"joke_generator\")\n        improve_agent = self.agent_factory.create_agent(\"joke_improver\")\n        polish_agent = self.agent_factory.create_agent(\"joke_polisher\")\n\n        # Register workflow nodes.\n        workflow.add_node(\n            \"joke_generator\", lambda state: gen_agent.run(topic=state[\"topic\"])\n        )\n        workflow.add_node(\n            \"joke_improver\", lambda state: improve_agent.run(joke=state[\"joke\"])\n        )\n        workflow.add_node(\n            \"joke_polisher\",\n            lambda state: polish_agent.run(improved_joke=state[\"improved_joke\"]),\n        )\n        # IP detector node; its result will be stored under \"ip_detector\".\n        workflow.add_node(\n            \"ip_detector\",\n            lambda state: ip_detector.run(\n                status=self.payload.response.status,\n                headers=self.payload.response.headers,\n            ),\n        )\n\n        # Aggregator node.\n        def format_topic(state: dict) -&gt; str:\n            topic = state.get(\"topic\", \"N/A\")\n            return f\"Topic: {topic}\"\n\n        def format_joke(state: dict) -&gt; str:\n            if state.get(\"joke\"):\n                return f\"Initial Joke: {state['joke']}\"\n            return \"Initial Joke: N/A\"\n\n        def format_ip_info(state: dict) -&gt; str:\n            status_line = \"BLOCKED\" if state.get(\"ip_blocked\") else \"Not Blocked\"\n            reason = state.get(\"ip_reason\", \"No block indicators detected\")\n            return f\"IP Detector: {status_line} ({reason})\"\n\n        def aggregator(state: dict) -&gt; dict:\n            parts = [format_topic(state), format_joke(state), format_ip_info(state)]\n            combined = \"\\n\".join(parts)\n            return {\"combined_output\": combined}\n\n        workflow.add_node(\"aggregator\", aggregator)\n\n        # Build edges: run ip_detector and joke_generator in parallel,\n        # then merge their outputs in aggregator.\n        workflow.add_edge(START, \"ip_detector\")\n        workflow.add_edge(START, \"joke_generator\")\n        workflow.add_conditional_edges(\n            \"joke_generator\",\n            self.check_punchline,\n            {\"Fail\": \"joke_improver\", \"Pass\": END},\n        )\n        workflow.add_edge(\"joke_improver\", \"joke_polisher\")\n        workflow.add_edge(\"ip_detector\", \"aggregator\")\n        workflow.add_edge(\"joke_generator\", \"aggregator\")\n        workflow.add_edge(\"aggregator\", END)\n        workflow.add_edge(\"joke_polisher\", END)\n\n        chain = workflow.compile()\n        log.debug(\"Workflow graph:\")\n        chain.get_graph().print_ascii()\n\n        state = chain.invoke({\"topic\": \"cats\"})\n\n        log.debug(\"Initial joke:\")\n        log.debug(state[\"joke\"])\n        log.debug(\"\\n--- --- ---\\n\")\n\n        if \"improved_joke\" in state:\n            log.debug(\"Improved joke:\")\n            log.debug(state[\"improved_joke\"])\n            log.debug(\"\\n--- --- ---\\n\")\n            log.debug(\"Final joke:\")\n            log.debug(state[\"final_joke\"])\n        else:\n            log.debug(\"Joke failed quality gate - no punchline detected!\")\n\n        log.debug(\"\\n---\")\n        log.debug(\"State\")\n        log.debug(state)\n        log.debug(\"\\n---\")\n\n        return {\n            \"usage\": \"scraping\",\n            \"bot_name\": self.payload.bot_name,\n            \"processed_data\": self.payload,\n            \"message\": state[\"combined_output\"],\n        }\n\n    def check_punchline(self, state: State):\n        \"\"\"Gate function to check if the joke has a punchline.\"\"\"\n        return \"Fail\" if (\"?\" in state[\"joke\"] or \"!\" in state[\"joke\"]) else \"Pass\"\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-workflows/code_reference/src/agents_workflows/scraping_workflow/#packages.agents-graph.agents-workflows.src.agents_workflows.scraping_workflow.ScrapingWorkflow.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Runs the scraping workflow.</p> Source code in <code>packages/agents-graph/agents-workflows/src/agents_workflows/scraping_workflow.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Runs the scraping workflow.\n    \"\"\"\n    await asyncio.sleep(0.5)\n    workflow = StateGraph(State)\n\n    # Dynamically create agents.\n    ip_detector = self.agent_factory.create_agent(\"ip_detector\")\n    gen_agent = self.agent_factory.create_agent(\"joke_generator\")\n    improve_agent = self.agent_factory.create_agent(\"joke_improver\")\n    polish_agent = self.agent_factory.create_agent(\"joke_polisher\")\n\n    # Register workflow nodes.\n    workflow.add_node(\n        \"joke_generator\", lambda state: gen_agent.run(topic=state[\"topic\"])\n    )\n    workflow.add_node(\n        \"joke_improver\", lambda state: improve_agent.run(joke=state[\"joke\"])\n    )\n    workflow.add_node(\n        \"joke_polisher\",\n        lambda state: polish_agent.run(improved_joke=state[\"improved_joke\"]),\n    )\n    # IP detector node; its result will be stored under \"ip_detector\".\n    workflow.add_node(\n        \"ip_detector\",\n        lambda state: ip_detector.run(\n            status=self.payload.response.status,\n            headers=self.payload.response.headers,\n        ),\n    )\n\n    # Aggregator node.\n    def format_topic(state: dict) -&gt; str:\n        topic = state.get(\"topic\", \"N/A\")\n        return f\"Topic: {topic}\"\n\n    def format_joke(state: dict) -&gt; str:\n        if state.get(\"joke\"):\n            return f\"Initial Joke: {state['joke']}\"\n        return \"Initial Joke: N/A\"\n\n    def format_ip_info(state: dict) -&gt; str:\n        status_line = \"BLOCKED\" if state.get(\"ip_blocked\") else \"Not Blocked\"\n        reason = state.get(\"ip_reason\", \"No block indicators detected\")\n        return f\"IP Detector: {status_line} ({reason})\"\n\n    def aggregator(state: dict) -&gt; dict:\n        parts = [format_topic(state), format_joke(state), format_ip_info(state)]\n        combined = \"\\n\".join(parts)\n        return {\"combined_output\": combined}\n\n    workflow.add_node(\"aggregator\", aggregator)\n\n    # Build edges: run ip_detector and joke_generator in parallel,\n    # then merge their outputs in aggregator.\n    workflow.add_edge(START, \"ip_detector\")\n    workflow.add_edge(START, \"joke_generator\")\n    workflow.add_conditional_edges(\n        \"joke_generator\",\n        self.check_punchline,\n        {\"Fail\": \"joke_improver\", \"Pass\": END},\n    )\n    workflow.add_edge(\"joke_improver\", \"joke_polisher\")\n    workflow.add_edge(\"ip_detector\", \"aggregator\")\n    workflow.add_edge(\"joke_generator\", \"aggregator\")\n    workflow.add_edge(\"aggregator\", END)\n    workflow.add_edge(\"joke_polisher\", END)\n\n    chain = workflow.compile()\n    log.debug(\"Workflow graph:\")\n    chain.get_graph().print_ascii()\n\n    state = chain.invoke({\"topic\": \"cats\"})\n\n    log.debug(\"Initial joke:\")\n    log.debug(state[\"joke\"])\n    log.debug(\"\\n--- --- ---\\n\")\n\n    if \"improved_joke\" in state:\n        log.debug(\"Improved joke:\")\n        log.debug(state[\"improved_joke\"])\n        log.debug(\"\\n--- --- ---\\n\")\n        log.debug(\"Final joke:\")\n        log.debug(state[\"final_joke\"])\n    else:\n        log.debug(\"Joke failed quality gate - no punchline detected!\")\n\n    log.debug(\"\\n---\")\n    log.debug(\"State\")\n    log.debug(state)\n    log.debug(\"\\n---\")\n\n    return {\n        \"usage\": \"scraping\",\n        \"bot_name\": self.payload.bot_name,\n        \"processed_data\": self.payload,\n        \"message\": state[\"combined_output\"],\n    }\n</code></pre>"},{"location":"reference/packages/agents-graph/agents-workflows/code_reference/src/agents_workflows/scraping_workflow/#packages.agents-graph.agents-workflows.src.agents_workflows.scraping_workflow.ScrapingWorkflow.check_punchline","title":"<code>check_punchline(state)</code>","text":"<p>Gate function to check if the joke has a punchline.</p> Source code in <code>packages/agents-graph/agents-workflows/src/agents_workflows/scraping_workflow.py</code> <pre><code>def check_punchline(self, state: State):\n    \"\"\"Gate function to check if the joke has a punchline.\"\"\"\n    return \"Fail\" if (\"?\" in state[\"joke\"] or \"!\" in state[\"joke\"]) else \"Pass\"\n</code></pre>"},{"location":"reference/packages/cliargs/","title":"CLIargs","text":"<p>CLIargs is a lightweight command-line interface helper library for Python, built on top of the standard <code>argparse</code> module. It provides a simple, consistent way to create and configure argument parsers with common utility flags that can be used across your applications.</p>"},{"location":"reference/packages/cliargs/#features","title":"Features","text":"<ul> <li>Easy Parser Creation: Quickly create an <code>ArgumentParser</code> with a provided description.</li> <li>Common Utility Flags: Pre-configured flags for verbosity, debugging, logging levels, and version information.</li> <li>Extensible: Built as a foundation that you can easily extend with custom flags and subcommands.</li> </ul>"},{"location":"reference/packages/cliargs/#usage","title":"Usage","text":"<p>Here's a basic example demonstrating how to create and use an argument parser with CLIargs:</p> <pre><code>from cliargs.cli import new_args_parser\n\ndef main():\n    parser = new_args_parser(\"Example Application\")\n    args = parser.parse_args()\n\n    if args.verbose:\n        print(\"Verbose mode enabled.\")\n    if args.debug:\n        print(\"Debug mode is active.\")\n\n    print(f\"Log level: {args.log_level}\")\n    print(f\"Configuration file: {args.config}\")\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"reference/packages/cliargs/#available-flags","title":"Available Flags","text":"<ul> <li><code>--verbose</code>: Enable verbose output.</li> <li><code>--debug</code>: Activate debug mode with detailed logging.</li> <li><code>--log-level</code>: Set the logging level (choices: DEBUG, INFO, WARNING, ERROR, CRITICAL; defaults to INFO).</li> <li><code>--version</code>: Print the library\u2019s version and exit.</li> </ul>"},{"location":"reference/packages/cliargs/#testing","title":"Testing","text":"<p>To run the tests for this library, navigate to the logger project directory and run:</p> <pre><code>uv --project packages/cliargs run pytest --cov=packages/cliargs/src/cliargs --cov-report=term-missing --cov-config=.coveragerc\n</code></pre> <p>This will execute the tests defined in the <code>packages/cliargs/tests</code> directory with coverage.</p>"},{"location":"reference/packages/cliargs/code_reference/src/cliargs/cli/","title":"Cli","text":"<p>Module for Creating a Standard Argument Parser</p> <p>This module provides a convenience function to generate an argparse.ArgumentParser instance with common command-line options such as verbose output, debug mode, logging level, and version information. It is designed to simplify the creation of consistent CLI interfaces across multiple applications.</p>"},{"location":"reference/packages/cliargs/code_reference/src/cliargs/cli/#packages.cliargs.src.cliargs.cli.new_args_parser","title":"<code>new_args_parser(description)</code>","text":"<p>Create and return an ArgumentParser with standard CLI options.</p> <p>This function initializes an argparse.ArgumentParser with the provided description and adds the following command-line arguments:</p> <pre><code>--verbose:\n    Enable verbose output.\n\n--debug:\n    Activate debug mode with detailed logging.\n\n--log-level:\n    Set the logging level. Acceptable values are \"DEBUG\", \"INFO\",\n    \"WARNING\", \"ERROR\", and \"CRITICAL\". Defaults to \"INFO\".\n\n--version:\n    Display the application's version and exit. The version is\n    hardcoded as \"0.1.0\".\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>A brief description of the application, which is displayed in the help message.</p> required <p>Returns:</p> Type Description <code>ArgumentParser</code> <p>argparse.ArgumentParser: An ArgumentParser object configured with the</p> <code>ArgumentParser</code> <p>standard command-line arguments.</p> Source code in <code>packages/cliargs/src/cliargs/cli.py</code> <pre><code>def new_args_parser(description: str) -&gt; argparse.ArgumentParser:\n    \"\"\"Create and return an ArgumentParser with standard CLI options.\n\n    This function initializes an argparse.ArgumentParser with the provided\n    description and adds the following command-line arguments:\n\n        --verbose:\n            Enable verbose output.\n\n        --debug:\n            Activate debug mode with detailed logging.\n\n        --log-level:\n            Set the logging level. Acceptable values are \"DEBUG\", \"INFO\",\n            \"WARNING\", \"ERROR\", and \"CRITICAL\". Defaults to \"INFO\".\n\n        --version:\n            Display the application's version and exit. The version is\n            hardcoded as \"0.1.0\".\n\n    Args:\n        description (str): A brief description of the application, which is\n            displayed in the help message.\n\n    Returns:\n        argparse.ArgumentParser: An ArgumentParser object configured with the\n        standard command-line arguments.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=description)\n    parser.add_argument(\"--verbose\", action=\"store_true\", help=\"Enable verbose output.\")\n    parser.add_argument(\n        \"--debug\",\n        action=\"store_true\",\n        help=\"Activate debug mode with detailed logging.\",\n    )\n    parser.add_argument(\n        \"--log-level\",\n        type=str,\n        default=\"INFO\",\n        choices=[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"],\n        help=\"Set the logging level. Defaults to INFO.\",\n    )\n    parser.add_argument(\n        \"--version\",\n        action=\"version\",\n        version=\"%(prog)s 0.1.0\",\n        help=\"Show the application's version and exit.\",\n    )\n    return parser\n</code></pre>"},{"location":"reference/packages/config/","title":"Config","text":"<p>The Config module provides a centralized configuration class for the agents-service. Using Python\u2019s dataclasses, this module simplifies handling configuration values that can be populated from environment variables and command-line arguments.</p>"},{"location":"reference/packages/config/#features","title":"Features","text":"<ul> <li> <p>Default Settings:   The <code>Config</code> class sets sensible defaults (for example, a log level of <code>INFO</code>) and reads environment variables to override those defaults.</p> </li> <li> <p>Validation:   The configuration is validated upon instantiation, ensuring that only supported log levels (e.g., DEBUG, INFO, WARNING, ERROR, CRITICAL) are accepted.</p> </li> <li> <p>Simplicity and Extensibility:   Easily extend the <code>Config</code> dataclass with additional fields for more configuration options as your service grows.</p> </li> </ul>"},{"location":"reference/packages/config/#usage","title":"Usage","text":"<p>Import and create an instance of <code>Config</code> to access your configuration settings:</p> <pre><code>from config.core import Config\n\n# Create a configuration instance; environment variables (e.g., LOG_LEVEL) will override defaults\nconfig = Config()\n\nprint(f\"Log Level: {config.log_level}\")\nprint(f\"Verbose: {config.verbose}\")\nprint(f\"Debug: {config.debug}\")\n</code></pre>"},{"location":"reference/packages/config/#example","title":"Example","text":"<p>Below is an example of how the configuration might be loaded from command-line arguments and environment variables in your main service:</p> <pre><code>import os\nfrom cliargs.cli import new_args_parser\nfrom config.core import Config\n\ndef load_config_from_args(args) -&gt; Config:\n    return Config(\n        log_level=args.log_level,\n        verbose=args.verbose,\n        debug=args.debug,\n    )\n\nparser = new_args_parser(\"Run agents-service.\")\nparser.add_argument(\"--agent\", type=str, help=\"Name of the agent to run\")\nparser.add_argument(\"--config\", type=str, default=\"config.yaml\", help=\"Path to configuration file\")\nargs = parser.parse_args()\n\nconfig = load_config_from_args(args)\nprint(config)\n</code></pre>"},{"location":"reference/packages/config/#testing","title":"Testing","text":"<p>To run the tests for this library, navigate to the logger project directory and run:</p> <pre><code>uv --project packages/config run pytest --cov=packages/config/src/config --cov-report=term-missing --cov-config=.coveragerc\n</code></pre> <p>This will execute the tests defined in the <code>packages/config/tests</code> directory with coverage.</p>"},{"location":"reference/packages/config/code_reference/src/config/core/","title":"Core","text":""},{"location":"reference/packages/config/code_reference/src/config/core/#packages.config.src.config.core.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"<p>Central configuration for the agents-service.</p> <p>Attributes:</p> Name Type Description <code>log_level</code> <code>str</code> <p>The log level for the application. It is obtained from the environment variable 'LOG_LEVEL' (default is 'INFO') and converted to uppercase.</p> <code>verbose</code> <code>bool</code> <p>If True, enables verbose output. Defaults to False.</p> <code>debug</code> <code>bool</code> <p>If True, activates debug mode with detailed logging. Defaults to False.</p> Source code in <code>packages/config/src/config/core.py</code> <pre><code>@dataclass\nclass Config:\n    \"\"\"Central configuration for the agents-service.\n\n    Attributes:\n        log_level (str): The log level for the application. It is obtained from\n            the environment variable 'LOG_LEVEL' (default is 'INFO') and converted to uppercase.\n        verbose (bool): If True, enables verbose output. Defaults to False.\n        debug (bool): If True, activates debug mode with detailed logging. Defaults to False.\n    \"\"\"\n\n    log_level: str = field(\n        default_factory=lambda: os.getenv(\"LOG_LEVEL\", \"INFO\").upper()\n    )\n    verbose: bool = field(default=False)\n    debug: bool = field(default=False)\n\n    def __post_init__(self):\n        \"\"\"Validates the configuration after initialization.\n\n        Raises:\n            ValueError: If the log_level is not one of the valid options.\n        \"\"\"\n        valid_levels = [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n        if self.log_level not in valid_levels:\n            raise ValueError(\n                f\"Invalid log level: {self.log_level}. Must be one of {valid_levels}\"\n            )\n</code></pre>"},{"location":"reference/packages/config/code_reference/src/config/core/#packages.config.src.config.core.Config.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validates the configuration after initialization.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the log_level is not one of the valid options.</p> Source code in <code>packages/config/src/config/core.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Validates the configuration after initialization.\n\n    Raises:\n        ValueError: If the log_level is not one of the valid options.\n    \"\"\"\n    valid_levels = [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n    if self.log_level not in valid_levels:\n        raise ValueError(\n            f\"Invalid log level: {self.log_level}. Must be one of {valid_levels}\"\n        )\n</code></pre>"},{"location":"reference/packages/logger/","title":"Logger Library","text":"<p>A simple logging library for Agents Service that provides JSON-formatted logging using python-json-logger. This library is designed to integrate seamlessly with your application while enabling structured logging for better observability and easier log parsing.</p>"},{"location":"reference/packages/logger/#features","title":"Features","text":"<ul> <li>JSON-Formatted Logging: Outputs log messages in JSON format, making it easier to ingest logs in modern logging systems.</li> <li>Configurable Log Levels: Set the log level via environment variables or directly in your code.</li> <li>Easy Integration: Simple API to set up logging in any module.</li> </ul>"},{"location":"reference/packages/logger/#usage","title":"Usage","text":"<p>Here's a quick example of how to use the logger library in your code:</p> <pre><code>from logger.log import setup_logging\n\n# Set up the logger for the current module\nlogger = setup_logging(__name__, log_level=\"DEBUG\")\n\nlogger.info(\"This is an informational message.\")\nlogger.error(\"An error occurred!\", extra={\"error_code\": 123})\n</code></pre>"},{"location":"reference/packages/logger/#testing","title":"Testing","text":"<p>To run the tests for this library, navigate to the logger project directory and run:</p> <pre><code>uv --project packages/logger run pytest --cov=packages/logger/src/logger --cov-report=term-missing --cov-config=.coveragerc\n</code></pre> <p>This will execute the tests defined in the <code>packages/logger/tests</code> directory with coverage.</p>"},{"location":"reference/packages/logger/code_reference/src/logger/log/","title":"Log","text":"<p>Logging module.</p>"},{"location":"reference/packages/logger/code_reference/src/logger/log/#packages.logger.src.logger.log.setup_logging","title":"<code>setup_logging(module_name, propagate=False, log_level=os.getenv('LOG_LEVEL', 'INFO').upper())</code>","text":"<p>Set up logging using JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>The module name.</p> required <code>propagate</code> <code>bool</code> <p>Whether to propagate the logging to the parent logger.</p> <code>False</code> <code>log_level</code> <code>str</code> <p>The log level.</p> <code>upper()</code> <p>Returns:</p> Type Description <code>Logger</code> <p>The logger.</p> Source code in <code>packages/logger/src/logger/log.py</code> <pre><code>def setup_logging(\n    module_name: str,\n    propagate: bool = False,\n    log_level: str = os.getenv(\"LOG_LEVEL\", \"INFO\").upper(),\n) -&gt; logging.Logger:\n    \"\"\"\n    Set up logging using JSON format.\n\n    Args:\n        module_name (str): The module name.\n        propagate (bool): Whether to propagate the logging to the parent logger.\n        log_level (str): The log level.\n\n    Returns:\n        The logger.\n    \"\"\"\n    log_handler = logging.StreamHandler()\n    formatter = json.JsonFormatter(\"%(levelname)s %(filename)s %(message)s\")\n    log_handler.setFormatter(formatter)\n\n    logger = logging.getLogger(module_name)\n    logger.addHandler(log_handler)\n    logger.propagate = propagate\n    logger.setLevel(logging.getLevelName(log_level))\n    return logger\n</code></pre>"},{"location":"reference/packages/logger/code_reference/src/logger/log/#packages.logger.src.logger.log.get_logger_from_env","title":"<code>get_logger_from_env(module_name)</code>","text":"<p>Get a logger using the <code>LOG_LEVEL</code> environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>The module name.</p> required <p>Returns:</p> Type Description <code>Logger</code> <p>The logger.</p> Source code in <code>packages/logger/src/logger/log.py</code> <pre><code>def get_logger_from_env(module_name: str) -&gt; logging.Logger:\n    \"\"\"\n    Get a logger using the `LOG_LEVEL` environment variable.\n\n    Args:\n        module_name (str): The module name.\n\n    Returns:\n        The logger.\n    \"\"\"\n    log_level = os.getenv(\"LOG_LEVEL\", \"INFO\").upper()\n    return setup_logging(module_name, log_level=log_level)\n</code></pre>"},{"location":"reference/packages/presenters/","title":"Presenters","text":"<p>The Presenters package is a core component of the Agents Service, responsible for exposing processed data and interfacing with external clients. It provides multiple presentation layers\u2014including REST APIs and WebSocket interfaces\u2014to facilitate real-time communication and control of the Agents Service.</p>"},{"location":"reference/packages/presenters/#overview","title":"Overview","text":"<p>The presenters package decouples presentation logic from the underlying business logic, ensuring a clean and maintainable codebase. It is divided into two main modules: - REST API Module: Handles HTTP requests and responses, providing endpoints for managing agents, retrieving reports, and configuring the service. - WebSocket Module: Enables real-time, bidirectional communication, streaming updates and notifications to connected clients.</p> <p>Both modules leverage a set of controllers and dependency management utilities to ensure consistency and ease of integration with the overall service architecture.</p>"},{"location":"reference/packages/presenters/#usage","title":"Usage","text":""},{"location":"reference/packages/presenters/#controllers-use-cases","title":"Controllers &amp; Use Cases","text":"<p>Each controller within the REST and WebSocket modules is designed to handle a specific set of operations. They typically: - Validate incoming requests. - Invoke the appropriate use case from the usecases library. - Format and return responses.</p>"},{"location":"reference/packages/presenters/#dependency-management","title":"Dependency Management","text":"<p>Both the REST and WebSocket modules use dedicated dependency files (<code>dependencies.py</code>) to manage configuration and dependencies. This design promotes modularity and eases testing. Ensure that any changes to external integrations are reflected in these files.</p>"},{"location":"reference/packages/security/","title":"Security","text":"<p>This package provides a simple JWT-based authentication system using FastAPI and PyJWT. It includes functions for creating and verifying access tokens, authenticating users against an in-memory database, and retrieving the current user from a JWT.</p>"},{"location":"reference/packages/security/#features","title":"Features","text":"<ul> <li>User Authentication: Validate user credentials against a simulated in-memory database.</li> <li>JWT Token Generation: Create JWT access tokens with configurable expiration.</li> <li>Token Verification: Decode and verify JWT tokens to ensure secure access.</li> <li>FastAPI Integration: Includes a FastAPI security dependency to extract and verify tokens in protected routes.</li> </ul>"},{"location":"reference/packages/security/#usage","title":"Usage","text":""},{"location":"reference/packages/security/#simulated-user-database","title":"Simulated User Database","text":"<p>The package includes a simulated user store (<code>FAKE_USERS_DB</code>) with sample users:</p> <pre><code>FAKE_USERS_DB = {\n    \"admin\": {\"username\": \"admin\", \"password\": \"admin123\", \"role\": \"admin\"},\n    \"user1\": {\"username\": \"user1\", \"password\": \"password123\", \"role\": \"agent\"},\n}\n</code></pre>"},{"location":"reference/packages/security/#authentication-and-token-creation","title":"Authentication and Token Creation","text":"<ul> <li>Authenticate a user: Use the <code>authenticate_user</code> function to verify user credentials.</li> <li>Login and get token: The <code>login_user</code> function authenticates a user and returns a JWT token.</li> </ul> <p>Example:</p> <pre><code>from datetime import timedelta\nfrom security.jwt import create_access_token\n\n# Attempt to login as admin\ntoken = login_user(\"admin\", \"admin123\")\nif token:\n    print(\"JWT Token:\", token)\nelse:\n    print(\"Invalid credentials\")\n</code></pre>"},{"location":"reference/packages/security/#token-verification-and-fastapi-integration","title":"Token Verification and FastAPI Integration","text":"<ul> <li>Token verification: The <code>verify_access_token</code> function decodes and validates the token.</li> <li>FastAPI Security Dependency: Use <code>get_current_user</code> in your FastAPI routes to extract user information.</li> </ul> <p>Example FastAPI route:</p> <pre><code>from fastapi import FastAPI, HTTPException, Security\nfrom fastapi.security import HTTPAuthorizationCredentials, HTTPBearer\n\napp = FastAPI()\nsecurity = HTTPBearer()\n\n@app.get(\"/protected\")\ndef protected_route(credentials: HTTPAuthorizationCredentials = Security(security)):\n    user = get_current_user(credentials)\n    return {\"message\": f\"Hello, {user['sub']}! Your role is {user['role']}\"}\n</code></pre>"},{"location":"reference/packages/security/#jwt-configuration","title":"JWT Configuration","text":"<ul> <li>Secret Key: The JWT secret key is loaded from the environment variable <code>JWT_SECRET_KEY</code>. If not provided, it defaults to <code>\"supersecretkey\"</code>. Make sure to change this in production.</li> <li>Algorithm: Uses <code>HS256</code> for token encoding and decoding.</li> <li>Expiration: Tokens expire in 30 minutes by default. This can be adjusted via the <code>ACCESS_TOKEN_EXPIRE_MINUTES</code> variable.</li> </ul>"},{"location":"reference/packages/security/#environment-variables","title":"Environment Variables","text":"<ul> <li>JWT_SECRET_KEY: The secret key used to sign JWT tokens. (Default: <code>supersecretkey</code>)</li> </ul> <p>Example (on Unix-like systems):</p> <pre><code>export JWT_SECRET_KEY=\"your-production-secret-key\"\n</code></pre>"},{"location":"reference/packages/security/code_reference/src/security/auth/","title":"Auth","text":""},{"location":"reference/packages/security/code_reference/src/security/auth/#packages.security.src.security.auth.authenticate_user","title":"<code>authenticate_user(username, password)</code>","text":"<p>Validate user credentials.</p> Source code in <code>packages/security/src/security/auth.py</code> <pre><code>def authenticate_user(username: str, password: str):\n    \"\"\"\n    Validate user credentials.\n    \"\"\"\n    user = FAKE_USERS_DB.get(username)\n    if not user or user[\"password\"] != password:\n        return None  # Invalid credentials\n    return user\n</code></pre>"},{"location":"reference/packages/security/code_reference/src/security/auth/#packages.security.src.security.auth.login_user","title":"<code>login_user(username, password)</code>","text":"<p>Authenticate and return a JWT token if successful.</p> Source code in <code>packages/security/src/security/auth.py</code> <pre><code>def login_user(username: str, password: str):\n    \"\"\"\n    Authenticate and return a JWT token if successful.\n    \"\"\"\n    user = authenticate_user(username, password)\n    if not user:\n        return None  # Invalid login\n\n    access_token = create_access_token(\n        {\"sub\": user[\"username\"], \"role\": user[\"role\"]},\n        expires_delta=timedelta(minutes=30),\n    )\n    return access_token\n</code></pre>"},{"location":"reference/packages/security/code_reference/src/security/dependencies/","title":"Dependencies","text":""},{"location":"reference/packages/security/code_reference/src/security/dependencies/#packages.security.src.security.dependencies.get_current_user","title":"<code>get_current_user(credentials=Security(security))</code>","text":"<p>Extract and validate the current user from JWT.</p> Source code in <code>packages/security/src/security/dependencies.py</code> <pre><code>def get_current_user(credentials: HTTPAuthorizationCredentials = Security(security)):\n    \"\"\"\n    Extract and validate the current user from JWT.\n    \"\"\"\n    token = credentials.credentials\n    try:\n        user_data = verify_access_token(token)\n        return user_data  # Returns user info (e.g., {\"sub\": \"admin\", \"role\": \"admin\"})\n    except ValueError as e:\n        raise HTTPException(status_code=401, detail=str(e))\n</code></pre>"},{"location":"reference/packages/security/code_reference/src/security/jwt/","title":"Jwt","text":""},{"location":"reference/packages/security/code_reference/src/security/jwt/#packages.security.src.security.jwt.create_access_token","title":"<code>create_access_token(data, expires_delta=None)</code>","text":"<p>Generate a JWT access token.</p> Source code in <code>packages/security/src/security/jwt.py</code> <pre><code>def create_access_token(data: Dict, expires_delta: timedelta = None):\n    \"\"\"\n    Generate a JWT access token.\n    \"\"\"\n    to_encode = data.copy()\n    expire = datetime.utcnow() + (\n        expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    )\n    to_encode.update({\"exp\": expire})\n    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n</code></pre>"},{"location":"reference/packages/security/code_reference/src/security/jwt/#packages.security.src.security.jwt.verify_access_token","title":"<code>verify_access_token(token)</code>","text":"<p>Verify and decode a JWT access token.</p> Source code in <code>packages/security/src/security/jwt.py</code> <pre><code>def verify_access_token(token: str):\n    \"\"\"\n    Verify and decode a JWT access token.\n    \"\"\"\n    try:\n        decoded_token = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return decoded_token  # Returns user info\n    except jwt.ExpiredSignatureError:\n        raise ValueError(\"Token has expired\")\n    except jwt.InvalidTokenError:\n        raise ValueError(\"Invalid token\")\n</code></pre>"},{"location":"reference/packages/security/code_reference/src/security/roles/","title":"Roles","text":""},{"location":"reference/src/","title":"Agents Service","text":""},{"location":"reference/src/#overview","title":"Overview","text":"<p>The Agents Service is a versatile, resilient solution designed to collect, analyze, and report on operational transactions from various domains. Initially built to handle web scraping transactions\u2014capturing detailed metadata such as HTTP requests/responses, headers, and body content\u2014the service is engineered with a modular architecture that supports diverse use cases.</p> <p>This robust system leverages AI-driven analysis to detect anomalies, optimize performance, and provide actionable insights for data engineers and system administrators. Its design is future-proof: as new requirements emerge, the Agents Service can easily incorporate additional data sources and analytical capabilities, extending its reach well beyond its original scope. Whether monitoring network traffic, processing API interactions, or integrating other data streams, the service ensures seamless adaptation and continuous improvement.</p>"},{"location":"reference/src/#key-components","title":"Key Components","text":"<p>The service is composed of several distinct components, each with a well-defined responsibility:</p>"},{"location":"reference/src/#configuration","title":"Configuration","text":"<p>The service is highly configurable via environment variables and configuration files. Key parameters include: - Logging Level: Set the verbosity of the logs for debugging or production.</p> <p>Configuration can be managed through a central config file (e.g., config/core.py) or via environment variables as outlined in the Config README.</p>"},{"location":"reference/src/#presenters","title":"Presenters","text":"<p>Presenters are responsible for exposing the processed data through various interfaces: - REST API: Provides endpoints for clients to retrieve reports, manage agents, or manage configurations. - WebSocket Interface: Enables real-time communication with connected clients, streaming updates and notifications as soon as analysis results become available. - CLI Tools: Facilitates direct command-line interaction for quick diagnostics, monitoring, or administrative tasks.</p> <p>For more detailed information on each presenter and how to leverage them, please refer to the Presenters README.</p> <p>Each presenter leverages a dedicated usecases library to encapsulate business logic and maintain a clean separation of concerns.</p>"},{"location":"reference/src/#use-cases","title":"Use Cases","text":"<p>The Agents Service encapsulates its business logic through a series of well-defined use cases. Each use case is responsible for a specific operation within the service and is designed with clean interfaces and dependency inversion in mind. This section details the primary use cases that drive the service\u2019s functionality.</p>"},{"location":"reference/src/#some-use-cases","title":"Some Use Cases","text":"<ul> <li>Get Agent Use Case: Retrieves detailed information about a specific agent using its unique identifier.</li> <li>Create Agent Use Case: Handles the creation of a new agent and its registration in the system.</li> <li>Orchestrator Use Case: Processes incoming payloads, determines the appropriate orchestrator based on the usage context, and delegates processing.</li> </ul> <p>For further details on the usecases library and its implementation, please refer to the Usecases README.</p>"},{"location":"reference/src/#architecture-diagram-plantuml","title":"Architecture Diagram (PlantUML)","text":"<p>Below is a PlantUML snippet that visually represents the relationships between the presenters and use cases:</p> <p></p>"}]}